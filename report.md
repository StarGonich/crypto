# Отчёт

## Потоковый шифр (RC4)

**Реализация алгоритма:**

```python
def get_key(S, x, y):
    x = (x + 1) % 256
    y = (y + S[x]) % 256

    S[x], S[y] = S[y], S[x]

    return S[(S[x] + S[y]) % 256], x, y


def rc4(msg: bytes, key: bytes, iv=None) -> bytearray:
    len_msg = len(msg)
    len_key = len(key)
    cipher = bytearray(len_msg)
    S = list(range(256))
    x = 0
    y = 0

    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len_key]) % 256
        S[i], S[j] = S[j], S[i]

    if iv is not None:
        for i in range(256):
            j = (j + S[i] + iv[i % len(iv)]) % 256
            S[i], S[j] = S[j], S[i]

    for i in range(len_msg):
        key_byte, x, y = get_key(S, x, y)
        cipher[i] = msg[i] ^ key_byte

    return cipher
```

### Принцип работы RC4

Алгоритм RC4 состоит из двух основных этапов:

1. **Инициализация S-блока (KSA - Key Scheduling Algorithm)**
   - Создается массив S размером 256 байт, инициализированный последовательностью 0-255
   - Ключ перемешивается с массивом S с помощью псевдослучайной перестановки
   - При наличии вектора инициализации (IV) выполняется дополнительное перемешивание

2. **Генерация ключевого потока (PRGA - Pseudo-Random Generation Algorithm)**
   - Генерируется ключевой поток той же длины, что и исходное сообщение
   - Каждый байт ключевого потока получается путем перестановки элементов в S-блоке
   - Исходные данные побитово складываются по модулю 2 (XOR) с ключевым потоком

**Особенности реализации:**
- Использование IV обеспечивает различное шифрование одинаковых сообщений с одним ключом
- Алгоритм симметричный - процедуры шифрования и дешифрования идентичны
- Не требует дополнения данных до определенного размера блока

## Блочный шифр (AES)

**Реализация алгоритма:**

```python
def aes_encrypt(mode: str, msg: bytes, key: bytes, iv=None) -> bytes:
    match mode:
        case 'ecb':
            cipher = AES.new(key, AES.MODE_ECB)
            msg = pad(msg, AES.block_size)
            encrypted_bytes = cipher.encrypt(msg)
        case 'cbc':
            if iv is None:
                iv = os.urandom(16)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            msg = pad(msg, AES.block_size)
            encrypted_bytes = iv + cipher.encrypt(msg)
        case 'ctr':
            if iv is None:
                iv = os.urandom(8)
            cipher = AES.new(key, AES.MODE_CTR, nonce=iv)
            encrypted_bytes = iv + cipher.encrypt(msg)
    return encrypted_bytes

    
def aes_decrypt(mode: str,  msg: bytes, key: bytes):
    match mode:
        case 'ecb':
            cipher = AES.new(key, AES.MODE_ECB)
            decrypted_bytes = cipher.decrypt(msg)
            decrypted_bytes = unpad(decrypted_bytes, AES.block_size)
        case 'cbc':
            iv = msg[:16]
            cipher = AES.new(key, AES.MODE_CBC, iv)
            decrypted_bytes = cipher.decrypt(msg[16:])
            decrypted_bytes = unpad(decrypted_bytes, AES.block_size)
        case 'ctr':
            nonce = msg[:8]
            cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)
            decrypted_bytes = cipher.decrypt(msg[8:])
    return decrypted_bytes
```

### Основные преобразования AES

Алгоритм AES оперирует блоками по 16 байт, организованными в матрицу 4×4. Процесс шифрования включает:

1. **KeyExpansion** - генерация раундовых ключей из исходного ключа
2. **AddRoundKey** - побитовое сложение состояния с раундовым ключом
3. **SubBytes** - нелинейная замена байт с использованием S-бокса
4. **ShiftRows** - циклический сдвиг строк матрицы состояния
5. **MixColumns** - преобразование столбцов с использованием умножения в поле Галуа

### Режимы работы AES

**ECB (Electronic Codebook)**
- Каждый блок шифруется независимо
- Простая реализация, но уязвим к анализу шаблонов
- Идентичные блоки дают идентичные зашифрованные блоки

**CBC (Cipher Block Chaining)**
- Каждый блок XOR-ится с предыдущим зашифрованным блоком
- Требует вектора инициализации (IV) для первого блока
- Устраняет проблемы ECB, но требует последовательной обработки

**CTR (Counter)**
- Преобразует блочный шифр в потоковый
- Использует счетчик и nonce для генерации ключевого потока
- Позволяет параллельную обработку и случайный доступ

## Сравнительный анализ

### Обработка данных изображений

Оба алгоритма используют единый подход к работе с изображениями:
- Преобразование изображения в байтовый массив
- Шифрование/дешифрование байтовых данных
- Восстановление изображения из обработанных байтов
- Функция `fix_bytes` обеспечивает корректное восстановление размеров

### Ключевые особенности

**RC4:**
- Потоковый характер - размер данных сохраняется
- Минимальные накладные расходы
- Простота реализации

**AES:**
- Блочная структура - требует выравнивания данных
- Различные режимы работы для разных сценариев
- Более сложная математическая основа
- Стандартизированный и широко принятый алгоритм

### Безопасность и производительность

Оба алгоритма демонстрируют:
- Высокую энтропию зашифрованных данных
- Низкую корреляцию между исходным и зашифрованным изображением
- Чувствительность к изменению ключа
- Соответствие криптографическим требованиям для визуальных данных

Выбор между RC4 и AES зависит от конкретных требований приложения: RC4 обеспечивает простоту и скорость, в то время как AES предлагает более надежную безопасность и гибкость через различные режимы работы.